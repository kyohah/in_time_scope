# frozen_string_literal: true

require "fileutils"

module InTimeScope
  # RBS type definition generator for InTimeScope.
  #
  # This generator creates RBS files for ActiveRecord models that use in_time_scope,
  # similar to how rbs_rails generates types for associations.
  #
  # == Usage
  #
  # In a Rails application, add a rake task:
  #
  #   # lib/tasks/in_time_scope.rake
  #   namespace :in_time_scope do
  #     desc "Generate RBS type definitions for InTimeScope"
  #     task generate_rbs: :environment do
  #       InTimeScope::RbsGenerator.generate_all
  #     end
  #   end
  #
  # Or use directly:
  #
  #   InTimeScope::RbsGenerator.generate(User)
  #   InTimeScope::RbsGenerator.generate_all
  #
  class RbsGenerator
    class << self
      # Generate RBS for all models that use InTimeScope
      #
      # @param output_dir [String] Directory to output RBS files (default: "sig/in_time_scope")
      # @return [Array<String>] List of generated file paths
      def generate_all(output_dir: "sig/in_time_scope")
        FileUtils.mkdir_p(output_dir)

        generated = []
        each_model_with_in_time_scope do |model|
          path = generate(model, output_dir: output_dir)
          generated << path if path
        end
        generated
      end

      # Generate RBS for a specific model
      #
      # @param model [Class] ActiveRecord model class
      # @param output_dir [String] Directory to output RBS files
      # @return [String, nil] Path to generated file, or nil if no scopes found
      def generate(model, output_dir: "sig/in_time_scope")
        scopes = extract_in_time_scopes(model)
        return nil if scopes.empty?

        rbs_content = generate_rbs_content(model, scopes)
        file_path = File.join(output_dir, "#{model.name.underscore}.rbs")

        FileUtils.mkdir_p(File.dirname(file_path))
        File.write(file_path, rbs_content)

        file_path
      end

      private

      def each_model_with_in_time_scope
        return enum_for(:each_model_with_in_time_scope) unless block_given?

        Rails.application.eager_load! if defined?(Rails) && Rails.respond_to?(:application)

        ActiveRecord::Base.descendants.each do |model|
          next if model.abstract_class?
          next unless model.respond_to?(:in_time_scope_definitions)

          yield model
        end
      end

      def extract_in_time_scopes(model)
        return [] unless model.respond_to?(:in_time_scope_definitions)

        model.in_time_scope_definitions
      end

      def generate_rbs_content(model, scopes)
        lines = []
        lines << "# Generated by InTimeScope::RbsGenerator"
        lines << "# Do not edit this file manually"
        lines << ""

        # Handle namespaced models
        namespaces = model.name.split("::")
        class_name = namespaces.pop

        namespaces.each do |ns|
          lines << "module #{ns}"
        end

        lines << "class #{class_name}"

        scopes.each do |scope_config|
          lines.concat(generate_scope_methods(scope_config))
        end

        lines << "end"

        namespaces.reverse_each do |_ns|
          lines << "end"
        end

        lines.join("\n") + "\n"
      end

      def generate_scope_methods(scope_config)
        lines = []
        scope_name = scope_config[:scope_method_name]
        pattern = scope_config[:pattern]

        # Class-level scope method
        lines << ""
        lines << "  # Scope for records within the time window"
        lines << "  def self.#{scope_name}: (?Time time) -> ActiveRecord::Relation[instance]"

        # Instance method
        lines << ""
        lines << "  # Check if record is within the time window"
        lines << "  def #{scope_name}?: (?Time time) -> bool"

        # Additional scopes for start-only or end-only patterns
        if %i[start_only end_only].include?(pattern)
          latest_name = scope_name == :in_time ? :latest_in_time : :"latest_#{scope_name}"
          earliest_name = scope_name == :in_time ? :earliest_in_time : :"earliest_#{scope_name}"

          lines << ""
          lines << "  # Scope for the latest record per foreign key (NOT EXISTS subquery)"
          lines << "  def self.#{latest_name}: (Symbol foreign_key, ?Time time) -> ActiveRecord::Relation[instance]"

          lines << ""
          lines << "  # Scope for the earliest record per foreign key (NOT EXISTS subquery)"
          lines << "  def self.#{earliest_name}: (Symbol foreign_key, ?Time time) -> ActiveRecord::Relation[instance]"
        end

        lines
      end
    end
  end
end
